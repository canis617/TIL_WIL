# Index

## 의미

- RDBMS에서 검색속도를 높이기 위해 사용하는 하나의 기술
- INDEX = 색인
- 해당 TABLE의 컬럼을 색인화(따로 파일로 저장)하여 검색시 해당 TABLE의 레코드를 full scan 하는게 아니라 색인화 되어있는 INDEX 파일을 검색하여 검색속도를 빠르게 한다.
- TREE 구조로 색인화 한다.
- RDBMS에서 사용하는 INDEX는 Balance Search Tree를 사용한다고 한다.
- 실제로는 RDBMS에서 사용되는 B-Tree 는 B-Tree에서 파생된 B+ Tree를 사용한다고 한다.

## 원리

- 해당 컬럼에 주게되면 초기 TABLE 생성시 만들어진 MYD, MYI, FRM 3개 파일중에서 MYI에 해당 컬럼을 색인화 하여 저장
- 사용자가 SELECT 쿼리로 INDEX가 사용하는 쿼리를 사용시 해당 TABLE을 검색하는 것이 아니라 빠른 TREE로 정리해둔 MYI 파일의 내용을 검색
- INDEX를 사용하지 않는 SELECT 쿼리라면 Full scan 한다.

## 장점

- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
- 질의나 보고서에서 그룹화 작업의 속도를 향상시킨다.
- 인덱스를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.
- 테이블의 기본 키는 자동으로 인덱스 된다.
- 필드 중에는 데이터 형식 때문에 인덱스 될 수 없는 필드도 있다.
- 여러 필드로 이루어진(다중 필드) 인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분할 수 있다.
- 참고로 엑세스에서 다중 필드 인덱스는 최대 10개의 필드를 포함할 수 있다.

## 단점

- 인덱스를 만들면 .mdb의 파일 크기가 늘어난다.
- 여러 사용자 응용 프로그램에서의 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 인덱스 된 필드에서 데이터를 업데이트 하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어진다.
- 인덱스가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다. (DB의 10퍼센트 내외의 공간)
- 인덱스를 생성하는데 시간이 많이 소요될 수 있다.
- 데이터 변경 작업이 자주 일어날 경우 인덱스를 재작성해야 할 필요가 있어 성능에 영향을 미친다.

## 목적

- 해당 RDBMS의 검색 속도를 높이는 데 있다.
- SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을때만 인덱스를 사용
- SELECT 쿼리의 검색 속도를 빠르게 하는데 목적을 두고있다.
- Update, Insert, Delete(Command)의 성능을 어느정도 희생한다. 하지만 행위가 느린것이지 update, delete를 위한 데이터의 조회의 성능은 올라간다.

## 인덱스 선정 기준

- 만약 하나의 인덱스만을 사용하면 해당 컬럼의 카디널리티(Cardinality)가 가장 높은 것을 잡아야 한다.
  - 카디널리티 : 해당 컬럼의 중복된 수치
  - 성별, 학년 등은 카디널리티가 낮고, 주민등록번호, 계좌번호 등은 카디널리티가 높다.

- 해당 인덱스로 최대의 효율을 꺼내야 되기 때문

- 여러 컬럼으로 인덱스를 구성시 카디널리티가 높은순에서 낮은순으로 구성하는게 더 성능이 뛰어나다.

- 여러 컬럼으로 인덱스를 활용할 시, 최소한 첫번째 인덱스 조건은 조회 조건에 포함되어야 한다.
  - 첫번째 인덱스 컬럼이 조회 쿼리에 없다면 인덱스를 타지 않는다.

## 주의사항

- between, like, <, > 등의 범위 조건은 해당 컬럼은 인덱스를 타지만, 그 뒤 컬럼들은 인덱스가 사용되지 않는다.
- =, in 은 다음 컬럼도 인덱스를 사용한다.
  - in은 결국 = 를 여러번 사용한 것이기 때문
  - 단 in 은 인자값으로 상수가 포함되면 상관 없으나, 서브쿼리를 넣게 되면 성능상 이슈가 발생한다.
  - 서브쿼리의 외부가 먼저 실행되고, in 은 체크 조건으로 실행되기 때문

- AND 연산자는 각 조건들이 읽어와야할 ROW 수를 줄이는 역할을 하지만, OR 연산자는 비교해야할 ROW가 더 늘어나기 때문에 full scan이 일어날 확률이 더 높다.
  - WHERE에서 OR을 사용할 때는 주의가 필요

- 인덱스로 사용된 컬럼값 그대로 사용해야만 인덱스가 사용된다.
  - 인덱스는 가공된 데이터를 저장하지 않는다.
  - 컬럼이 문자열인데 숫자로 조회하면 타입이 달라 인덱스가 사용되지 않는다.

## 인덱스 구조

### B-Tree Index

![B-Tree Index](https://t1.daumcdn.net/cfile/tistory/99240D3359FEEDA92A)

- 인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행
  - 예를 들어 Branch(페이지번호 2)는 dept_no가 d001이면서 emp_no가 10017~10024 까지인 Leaf의 부모로 있다.
  - 즉 dept_no=d001 and emp_no=10018로 조회하면 페이지 번호 4인 Leaf를 찾아 데이터 파일의 주소를 불러와 반환하는 과정을 하게 된다.

- 인덱스의 두번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다.
  - 즉, 두번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 열에서만 의미가 있다.
  - 3번째, 4번째 인덱스 컬럼도 있다면 두번째 컬럼과 마찬가리조 3번째 컬럼은 2번째 컬럼에 의존하게 된다.

- 디스크에서 읽는 것은 메모리에서 읽는것보다 성능이 훨씬 떨어진다.
  - 결국 인덱스 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 만드느냐, 인덱스 Root에서 Leaf까지 오고가는 횟수를 얼마나 줄이느냐에 달려있다.

- 인덱스의 갯수는 3~4개 정도가 적당하다.
  - 너무 많은 인덱스는 새로운 Row를 등록할 때마다 인덱스를 추가해야하고, 수정/삭제시마다 인덱스 수정이 필요해 성능상 이슈가 된다.
  - 인덱스 역시 공간을 차지한다.
  - 많은 인덱스들로 인해 옵티마이저가 잘못된 인덱스를 선택할 확률이 높다.

### Clustered Index

![Index](https://camo.githubusercontent.com/ed28acb9406a339ec9730a55eda869eefefb3987bfea4892afcb97fe70fa3cab/68747470733a2f2f6a756a7562656261742e6769746875622e696f2f6173736574732f696d616765732f323032302d31302d30392d31322d34322d34312e706e67 "부가설명")

- 데이터가 정렬된(PK 혹은 UNIQUE NOT NULL 컬럼을 기준으로 오름차순) 상태(유지)로 저장
- 테이블 당 한 개만 생성
- 제약조건 PRIMARY KEY에 의해 자동으로 생성
- 제약조건 UNIQUE NOT NULL에 의해 자동으로 생성
  - 두개가 같이 있을 경우 P_Key를 Clustered Index로 사용
- 데이터 검색 순서
  - 루트 페이지 > 리프 페이지 (=데이터 페이지)

- 클러스터드 인덱스는 인덱스 자체도 정렬되어 있고, 인덱스에 해당하는 튜플(레코드)도 정렬되어 있는 방식이다. 또한 인덱스와 튜플이 저장되는 공간이 같다.
- 인덱스들과 각 인덱스에 해당하는 튜플이 미리 정렬되어 있으므로 빠르게 튜플을 찾을 수 있다. 특히 범위 조회시 유리하다.
- 튜플들을 정렬해서 관리하기 때문에 튜플을 INSERT, DELETE, UPDATE 할 때 재정렬 오버헤드가발생한다. (배열에 새로운 원소를 삽입하거나 삭제하려면, 기존 원소들을 한칸씩 옮겨줘서 원소들을 재배치 하는 것과 같다.)
- 클러스터드 인덱스는 프라이머리 키에 대해서만 적용되는 개념이다.
- 위 그림 오른쪽을 보면 인덱스는 프라이머리 키로 정렬되어 있다. 프라이머리 키에 해당하는 튜플 역시 정렬되어 있는 것을 볼 수 있다.

### Non-Clustered Index = Secondary Index

- 테이블에 여러개의 보조 인덱스를 생성할 수 있다.
- 제약조건 UNIQUE에 의해 자동으로 생성
- 별도의 인덱스가 생성되지만, 원본 데이터는 변경되지 않음
- 데이터 검색 순서
  - 루트 페이지 > 리프 페이지 > 데이터 페이지(Heap Page)
  - Heap : 정렬 기준 없이 구성된 테이블 (입력된 순서대로 저장)
  - 리프 페이지는 데이터 페이지를 가리키는 주소값(RID)을 가지고 있다.

- 리프 페이지가 모두 차 있더라도 페이지 분할이 일어나지 않는다.
  - INSERT, DELETE, UPDATE, 성능이 Clustered Index 보다 낫다.

- 넌 클러스터드 인덱스는 인덱스 자체는 정렬되어 있지만, 인덱스에 해당하는 튜플(레코드)은 정렬되어 있지 않다. 또한 인덱스와 튜플이 저장되는 공간이 다르다.
- 위 그림 왼쪽을 보면 날짜 컬럼이 인덱스로 잡혀있으며, 날짜 컬럼 인덱스들이 정렬되어 있는 것을 볼 수 있다. 하지만 날짜에 해당하는 실제 튜플의 주소는 정렬되어 있지 않는 것을 볼 수 있다.
- 또한 날짜 컬럼 인덱스를 통해 원하는 날짜에 해당하는 튜플의 프라이머리 키(주소)를 알아내고, 프라이머리 키를 통해 튜플에 접근하는 것을 볼 수 있다.
