# 내용협상과 트랜스 코딩

- [참조 사이트](https://feel5ny.github.io/2020/01/20/HTTP_017/)

- http는 클라이언트와 서버가 서로 내용을 협상 할 수 있도록 방법을 제공 = 내용 협상(content-negotiation)
- 하나의 URL이 여러가지 리소스 중 적합한 것에 대응되도록 할 수 있다.
  - 여기서는 서로 다른 버전을 `variant`라고 부른다
- 서버는 특정 url에 대해 어떤 콘텐츠가 클라에게 보내주기 가장 적절한지 판단도 할 수 있어야 한다.
- 트랜스코딩은 http 클라이언트와 서버 사이의 내용 협상에 대한 응답에서 수행된다.

---

## 내용 협상 기법

- 서버에 있는 페이들 중 어떤 것이 클라이언트에게 맞는지 판단하는 3가지 방법

1. 클라이언트에게 선택지를 줌 = __클라이언트 주도 협상__
   - HOW : 클라이언트가 요청을 보내면, 서버는 클라이언트에게 선택지를 보내주고, 클라이언트가 선택
   - 장점 : 서버입장에서 구현하기 쉽다.
   - 단점 : 대기 시간이 증가한다. 즉, 올바른 콘텐츠를 얻기 위해 최소 두번의 요청이 필요

2. 서버가 자동으로 판단 = __서버 주도 협상__
   - HOW : 서버가 클라이언트 요청 헤더를 검증해서 어떤 버전을 제공할지 결정
   - 장점 : 클라 주도 협상보다 빠르다
      - HTTP는 서버가 가장 적절한 것을 선택 할 수 있도록 q값 매커니즘을 제공
      - 서버가 다운스트림 장치에게 요청이 어떻게 평가되는지 말해줄 수 있도록 하기 위해 `Vary` 헤더를 제공
   - 단점 : 만약 결정이 뻔하지 않으면(헤더에 맞는 것이 없으면), 서버는 추측해서 넘겨야함
3. 중개자에게 선택하도록 부탁하는 방법 = __투명한 협상__
   - HOW : 투명한 중간장치(주로 Proxy 캐시)가 서버를 대신하여 협상을 한다.
   - 장점 : 웹서버가 협상 할 필요가 없다. 클라 주도 협상보다 빠르다
   - 단점 : 투명 협상을 어떻게 하느냐에 대한 정형화된 명세가 없다.

---

## 클라 주도 협상

- 서버에게 있어 가장 쉬운 방법
  - 서버가 클라의 요청을 받았을 때, 가능한 페이지의 목록을 응답으로 돌려주어 클라가 보고 싶은 것을 선택하게 하는 것이다.
  - 서버 입장에서 구현하기 쉽고, 최선의 사본이 선택될 것이다.

- 단점
  - (기술측면) 각 페이지에 두 번의 요청이 필요하다는 것. 한번은 목록을 얻고 두번째는 선택한 사본을 얻는다.
    - 선택지를 표현하는 2가지 방법
    - 여러가지 버전에 대한 링크와 설명이 담긴 html
    - 300 Multiple Choices 응답코드로 응답을 돌려주는 것. (상태코드 글 참고)
  - (ux측면) 여러개의 url을 요구한다는 점
    - 예) 아래처럼 여러 url을 요구할 것이다.
      - https://feel5ny.github.io/korean
      - https://feel5ny.github.io/english
    - 어떤 링크를 메인 링크라고 생각할 것인가? (공유할때나, 북마킹할때 등등)

---

## 서버 주도 협상

- 불필요한 커뮤니케이션 비용을 줄이는 방향으로
  - 서버가 어떤 페이지를 돌려줄 것인지 결정하게 하는 것.
  - 클라는 반드시 자신이 무엇을 선호하는지에 대한 충분한 정보를 서버에게 주어서, 서버가 현명한 결정을 할 수 있게 해 주어야 한다.

- http 서버가 클라에게 보내줄 적절한 응답을 계산하기 위해 사용하는 메커니즘은 2가지
  - 내용 협상 헤더들을 살펴본다.
    - 서버는 클라의 Accept 관련 헤더들을 들여다보고, 그에 알맞은 응답 헤더를 준비한다.
  - 내용 협상 헤더 외의 다른 헤더들을 살펴본다.
    - 예_서버는 클라의 User-Agent 헤더에 기반하여 응답을 보내줄 수도 있다.

### 내용 협상 헤더

- `Accept` : 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.
- `Accept-Language` : 서버가 어떤 언어로 보내도 되는지 알려준다.
- `Accept-Charset` : 서버가 어떤 charset을 보내도 되는지 알려준다.
- `Accept-Encoding` : 서버가 어떤 인코딩을 보내도 되는지 알려준다.

내용 협상 헤더들은

1. 클라와 서버가 선호 정보를 서로 교환
1. 문서들의 여러 버전 중 하나를 선택하는 것을 도움
1. 클라의 선호에 가장 잘 맞는 문서를 제공해 주기 위한 목적

- 만약에 클라중 하나가 일본어를 선호한다면 한국어을 돌려줘야할까 영어를 돌려줘야할까.
  - 한국어를 좀 더 선호한다면, 선호한다는 의사 정보를 추가하여 전달할 수 있으면 좋겠다고 생각할 것이다.
- HTTP는 풍부한 설명을 품질값을 이용해 전달할 수 있는 메커니즘을 제공한다.
  - quality value, 줄여서 `q`값

### 내용 협상 헤더의 품질값

- HTTP 프로토콜은 클라가 각 선호의 카테고리마다, 여러 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 품질값을 정의하였다.

```bash
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```

- q는 0.0부터 1.0까지의 값을 가질 수 있다.

- 위 상황은 네덜란드어(nl)로 된 문서를 받기 원하고 잇으나 영어(en)로 된 문서라도 받아들일 것임을 의미한다.

- 때때로 서버는 클라의 선호에 대응하는 문서를 하나도 갖고있지 않을 수 도 있다.
  - 이 경우, 서버는 클라의 선호에 맞추기 위해 문서를 고치거나 트랜스코딩 할 수 있다.

### 그 외의 헤더들에 의해 결정

- 서버는 또한 User-Agent와 같은 클라의 다른 요청 헤더들을 이용해 알맞은 요청을 만들어내려고 시도할 수 있다.
- 최선에 가장 가까운 대응을 찾아낼 수 있는 q값 매커니즘은 없다.
- 서버는 정확한 대응을 찾아내거나, 그냥 갖고 있는 것을 제공해주어야 한다.
- 캐시는 반드시 캐시된 문서의 올바른 ‘최선의’ 버전을 제공해주려 해야 하기 때문에, HTTP 프르토콜은 서버가 응답에 넣어 보낼 수 있는 `Vary` 헤더를 정의한다.
  - `Vary` 헤더는 캐시에게 서버가 내줄 응답의 최선의 버전을 결정하기 위해 어떤 요청 헤더를 참고하고 있는지 말해준다.

---

## 투명 협상

- 클라 입장에서 협상하는 중개자 프락시를 둠으로써, 클라와의 메세지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거한다.
- 투명한 내용 협상을 지원하기 위해, http에서 정의한 `Vary` 헤더를 사용한다.
  - 서버는 어떤 요청 헤더를 검사해야 하는지 프락시에게 `Vary` 헤더를 통해 말해준다.

### 캐시와 얼터네이트 alternate

- 캐시는 클라의 요청을 서버로 그대로 전달하고, 응답을 저장
- 두번째 요청시 응답은 캐시가 URL에 대응하는 문서를 찾아서 돌려줄 것인데, 이 때 다른 언어의 문서를 원한다면, 캐시는 이번 응답과 새로운 응답 두개를 저장해야함
- 이 다른 버전은 Variant(배리언트)나 얼터네이트(alternate)라고 불린다.

### Vary 헤더

- http Vary 응답 헤더
  - 서버가 문서를 선택하거나, 커스텀 콘텐츠를 생성할 때 고려한 __클라이언트 요청 헤더 모두를 나열__
- 새 요청이 도착했을 때, 캐시는 내용 협상 헤더들을 이용해 가장 잘 맞는것을 찾음
  - 캐시는 반드시 캐시된 응답 안에 서버가 보낸 `Vary`헤더가 들어있는지 확인하고, `Vary` 헤더가 명시하고 있던 헤더들은 새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야 한다.
    - 서버는 클라의 요청 헤더에 따라 그들의 응답이 달라질 수 있기 때문에 투명 협상을 구현하기 위해 캐시는 반드시 __캐시된 variant__ 와 함께 클라 요청 헤더와 그에 알맞은 서버 응답헤더 양쪽 모두를 저장해야한다.

```bash
Vary: User-Agent, Cookie
```

- 서버의 Vary 헤더가 이렇다면, 거대한 수의 다른 User-Agent와 Cookie들이 많은 배리언트를 만들어 낼 것
- 캐시는 각 배리언트 마다 알맞은 문서 버전을 저장해야
- 캐시가 검색을 할 때
  1. 먼저 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고
  1. 다음에 요청의 배리언트를 캐시된 배리언트와 맞춰본 뒤
  1. 만약 맞는 것이 없으면, 캐시는 문서를 서버에서 가져오고, 맞는 것이 있다면 해당 콘텐츠를 보여준다.

![vary](https://feel5ny.github.io/images/2020/04/03.png)

---

## 트랜스 코딩

- 서버가 클라이언트의 요구에 맞는 문서를 아예 가지고 있지 않다면?
  - 이론적으로는 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수도 있다.
  - 이것이 __트랜스코딩__ 이다.

1. HTML 문서 > WML 문서
1. 고해상도 이미지 > 저해상도 이미지
1. 64K색 이미지 > 흑백 이미지
1. 프레임을 포함한 복잡한 페이지 > 프레임이나 이미지가 없는 단순한 텍스트 페이지
1. 자바 애플릿이 있는 HTML 페이지 > 자바 애플릿이 없는 페이지
1. 광고가 있는 페이지 > 광고가 없는 페이지
...

---

1. 포멧 변환
   - 포맷 변환은 데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것
1. 정보 합성
   - 문서에서 정보의 요점을 추출하는 것을 정보 합성이라고 한다. __information synthesis__
   - 각 절의 제목에 기반한 문서의 개요 생성이나, 페이지에서 광고 및 로고 제거를 들 수 있다.
      - 본문의 키워드에 기반하여 페이지를 분류하는 더 복잡한 기술은 문서의 핵심을 요약할 때도 역시 유용하다.
   - 이 기술을 포털사이트의 웹페이지 디렉터리와 같은 자동화된 웹페이지 분류 시스템에 의해 종종 사용된다.
1. 콘텐츠 주입
   - 포맷 변환과 정보 합성은 문서의 양을 줄이지만 주입 트랜스코딩은 오히려 양을 늘린다.
   - 내용 주입 트랜스 코딩의 예로 자동 광고 생성과 사용자 추적 시스템이 있다.
   - 동적으로 문서에 추가된다.
1. 트랜스 코딩 vs 정적으로 미리 생성해놓기
   - 트랜스 코딩의 대안은 웹서버에서 웹페이지의 여러가지 사본을 만드는 것이다.
      - 예_고해상도는 저해상도 이미지를 만든다.
   - 여러가지 이유로 그다지 현식적인 기법이 못된다.
      - 페이지에 대한 어떠한 작은 변화도 여러 페이지의 수정을 요구하게 되고
      - 각 페이지의 모든 버전을 저장하기 위해 더 많은 공간이 필요하게 되며
      - 페이지들을 관리하고, 그것들 중 올바른 것을 골라서 제공해주는 웹서버를 프로그래밍하기 어려워진다.
   - 변환은 더 싼 프락시나 캐시에 있는 외부 에이전트에 의해 수행될 수 있다.

